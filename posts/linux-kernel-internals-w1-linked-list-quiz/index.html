<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Linux Kernel Internals - w1 - linked-list-quiz - sharefun</title><meta name=description content="This is the homework of jserv&rsquo;s Linux Kernel Internals.
Reference: Quiz 1"><meta name=author content><link rel="preload stylesheet" href=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.css><script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script>MathJax={tex:{inlineMath:[["$","$"]],displayMath:[["$$","$$"]]}}</script><script id=MathJax-script defer src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script>
<link rel="preload stylesheet" href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.2/styles/gruvbox-dark.min.css><script defer src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.2/highlight.min.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon type=image/x-icon href=https://hfyeh.github.io/images/favicon.ico><link rel=apple-touch-icon href=https://hfyeh.github.io/images/apple-touch-icon-dark.png><link rel=stylesheet href=https://hfyeh.github.io/stylesheets/dark.css><link rel="preload stylesheet" as=style href=https://hfyeh.github.io/custom.min.css><meta name=generator content="Hugo 0.111.3"><meta property="og:title" content="Linux Kernel Internals - w1 - linked-list-quiz"><meta property="og:description" content="This is the homework of jserv&rsquo;s Linux Kernel Internals.
Reference: Quiz 1"><meta property="og:type" content="article"><meta property="og:url" content="https://hfyeh.github.io/posts/linux-kernel-internals-w1-linked-list-quiz/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-10-28T00:00:00+00:00"><meta property="article:modified_time" content="2022-10-28T00:00:00+00:00"><meta itemprop=name content="Linux Kernel Internals - w1 - linked-list-quiz"><meta itemprop=description content="This is the homework of jserv&rsquo;s Linux Kernel Internals.
Reference: Quiz 1"><meta itemprop=datePublished content="2022-10-28T00:00:00+00:00"><meta itemprop=dateModified content="2022-10-28T00:00:00+00:00"><meta itemprop=wordCount content="1080"><meta itemprop=keywords content="blog,linked-list,draft,"><meta name=twitter:card content="summary"><meta name=twitter:title content="Linux Kernel Internals - w1 - linked-list-quiz"><meta name=twitter:description content="This is the homework of jserv&rsquo;s Linux Kernel Internals.
Reference: Quiz 1"></head><body><div class="grid grid-centered"><div class=grid-cell><nav class="header-nav scrollappear"><a href=/ class=header-logo title=sharefun>sharefun</a><ul class=header-links><li><a href=https://www.facebook.com/sharefun010407 rel="noreferrer noopener" target=_blank title=Facebook><svg xmlns="http://www.w3.org/2000/svg" class="icon-facebook"><use href="https://hfyeh.github.io/icons/facebook.svg#icon-facebook" xlink:href="https://hfyeh.github.io/icons/facebook.svg#icon-facebook"/></svg></a></li><li><a href=https://github.com/hfyeh rel="noreferrer noopener" target=_blank title=GitHub><svg xmlns="http://www.w3.org/2000/svg" class="icon-github"><use href="https://hfyeh.github.io/icons/github.svg#icon-github" xlink:href="https://hfyeh.github.io/icons/github.svg#icon-github"/></svg></a></li><li><a href=https://twitter.com/SharefunYeh rel="noreferrer noopener" target=_blank title=Twitter><svg xmlns="http://www.w3.org/2000/svg" class="icon-twitter"><use href="https://hfyeh.github.io/icons/twitter.svg#icon-twitter" xlink:href="https://hfyeh.github.io/icons/twitter.svg#icon-twitter"/></svg></a></li></ul></nav><article class="article scrollappear"><header class=article-header><h1>Linux Kernel Internals - w1 - linked-list-quiz</h1></header><div class=article-list-header><span class=article-list-date>October 28, 2022</span></div><div class=article-content><p>This is the homework of <a href=https://github.com/jserv>jserv</a>&rsquo;s <a href=https://wiki.csie.ncku.edu.tw/linux/schedule>Linux Kernel Internals</a>.</p><p>Reference: <a href=https://hackmd.io/@sysprog/linked-list-quiz>Quiz 1</a></p><h2 id=q1-分析以下程式碼推敲-funca-funcb-funcc-的作用並且推測程式執行結果>Q1. 分析以下程式碼，推敲 FuncA, FuncB, FuncC 的作用，並且推測程式執行結果。</h2><p><img src=https://i.imgur.com/I4mcQ7d.png alt></p><ul><li>首先看到 struct node 為節點的結構，有一個 int 儲存資料，及一個 next pointer, prev pointer，因此可以推測其為一個雙向的 linked list</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> node {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> data;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> node <span style=color:#f92672>*</span>next, <span style=color:#f92672>*</span>prev;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h3 id=1-funca-的作用是>1. FuncA 的作用是？</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>FuncA</span>(<span style=color:#66d9ef>struct</span> node <span style=color:#f92672>**</span>start, <span style=color:#66d9ef>int</span> value) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!*</span>start) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> node <span style=color:#f92672>*</span>new_node <span style=color:#f92672>=</span> <span style=color:#a6e22e>malloc</span>(<span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>struct</span> node));
</span></span><span style=display:flex><span>        new_node<span style=color:#f92672>-&gt;</span>data <span style=color:#f92672>=</span> value;
</span></span><span style=display:flex><span>        new_node<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> new_node<span style=color:#f92672>-&gt;</span>prev <span style=color:#f92672>=</span> new_node;
</span></span><span style=display:flex><span>        <span style=color:#f92672>*</span>start <span style=color:#f92672>=</span> new_node;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> node <span style=color:#f92672>*</span>last <span style=color:#f92672>=</span> (<span style=color:#f92672>*</span>start)<span style=color:#f92672>-&gt;</span>prev;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> node <span style=color:#f92672>*</span>new_node <span style=color:#f92672>=</span> <span style=color:#a6e22e>malloc</span>(<span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>struct</span> node));
</span></span><span style=display:flex><span>    new_node<span style=color:#f92672>-&gt;</span>data <span style=color:#f92672>=</span> value;
</span></span><span style=display:flex><span>    new_node<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>start;
</span></span><span style=display:flex><span>    (<span style=color:#f92672>*</span>start)<span style=color:#f92672>-&gt;</span>prev <span style=color:#f92672>=</span> new_node;
</span></span><span style=display:flex><span>    new_node<span style=color:#f92672>-&gt;</span>prev <span style=color:#f92672>=</span> last;
</span></span><span style=display:flex><span>    last<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> new_node;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>If <code>*start</code> does not exist, malloc <code>*new_node</code> for it. And since the note will be an element of a doubly-linked list, the <code>*next</code> member should be <code>*new_node</code> itself if <code>*start</code> is <code>NULL</code>.</li><li>If <code>*start</code> does exist, malloc and insert new node to tail.</li></ul><p>So <code>FuncA</code> insert a new node to the tail of linked list <code>*start</code> (whether it&rsquo;s empty or not), the <code>node->value</code> is <code>value</code> given in function parameter.</p><h4 id=visualization-the-if-block>Visualization the if block</h4><pre tabindex=0><code class=language-mermaid data-lang=mermaid>flowchart LR
    start
</code></pre><p><code>*start = new_node</code></p><pre tabindex=0><code class=language-mermaid data-lang=mermaid>flowchart LR
    start --&gt; new_node
</code></pre><h4 id=visualization-outside-the-if-block>Visualization outside the if block</h4><pre tabindex=0><code class=language-mermaid data-lang=mermaid>flowchart LR
    start --&gt; node1
    node1 &lt;--&gt; node2
    node2 &lt;--&gt; node3
    node3[&#34;node3 (last)&#34;] &lt;--&gt; node1
    new_node
</code></pre><p><code>new_node->next = *start</code> and <code>(*start)->prev = new_node</code></p><pre tabindex=0><code class=language-mermaid data-lang=mermaid>flowchart LR
    start --&gt; node1
    node1 &lt;--&gt; node2
    node2 &lt;--&gt; node3
    node3[&#34;node3 (last)&#34;] --&gt; node1
    new_node &lt;==&gt; node1
</code></pre><p><code>new_node->prev = last;</code> and <code>last->next = new_node;</code></p><pre tabindex=0><code class=language-mermaid data-lang=mermaid>flowchart LR
    start --&gt; node1
    node1 &lt;--&gt; node2
    node2 &lt;--&gt; node3
    node3[&#34;node3 (last)&#34;] &lt;==&gt; new_node
    new_node &lt;---&gt; node1
</code></pre><h3 id=2-funcb-的作用是>2. FuncB 的作用是？</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>FuncB</span>(<span style=color:#66d9ef>struct</span> node <span style=color:#f92672>**</span>start, <span style=color:#66d9ef>int</span> value) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> node <span style=color:#f92672>*</span>last <span style=color:#f92672>=</span> (<span style=color:#f92672>*</span>start)<span style=color:#f92672>-&gt;</span>prev;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> node <span style=color:#f92672>*</span>new_node <span style=color:#f92672>=</span> <span style=color:#a6e22e>malloc</span>(<span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>struct</span> node));
</span></span><span style=display:flex><span>    new_node<span style=color:#f92672>-&gt;</span>data <span style=color:#f92672>=</span> value;
</span></span><span style=display:flex><span>    new_node<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>start;
</span></span><span style=display:flex><span>    new_node<span style=color:#f92672>-&gt;</span>prev <span style=color:#f92672>=</span> last;
</span></span><span style=display:flex><span>    last<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> (<span style=color:#f92672>*</span>start)<span style=color:#f92672>-&gt;</span>prev <span style=color:#f92672>=</span> new_node;
</span></span><span style=display:flex><span>    <span style=color:#f92672>*</span>start <span style=color:#f92672>=</span> new_node;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>FuncB</code> insert a new node to the begining of the linked list <code>*start</code>, the <code>node->value</code> is <code>value</code> in function paramter.</p><p>Note that <code>*start</code> cannot be <code>NULL</code>.</p><h4 id=visualization-of-funcb>Visualization of FuncB</h4><pre tabindex=0><code class=language-mermaid data-lang=mermaid>flowchart LR
    start --&gt; node1
    node1 &lt;--&gt; node2
    node2 &lt;--&gt; node3
    node3[&#34;node3 (last)&#34;] &lt;--&gt; node1
    new_node
</code></pre><p><code>new_node->next = *start</code></p><pre tabindex=0><code class=language-mermaid data-lang=mermaid>flowchart LR
    start --&gt; node1
    node1 &lt;--&gt; node2
    node2 &lt;--&gt; node3
    node3[&#34;node3 (last)&#34;] &lt;--&gt; node1
    new_node ==&gt; node1
</code></pre><p><code>new_node->prev = last</code></p><pre tabindex=0><code class=language-mermaid data-lang=mermaid>flowchart LR
    start --&gt; node1
    node1 &lt;--&gt; node2
    node2 &lt;--&gt; node3
    node3[&#34;node3 (last)&#34;] &lt;--&gt; node1
    new_node --&gt; node1
    new_node ==&gt; node3
</code></pre><p><code>last->next = (*start)->prev = new_node;</code></p><pre tabindex=0><code class=language-mermaid data-lang=mermaid>flowchart LR
    start --&gt; node1
    node1 &lt;--&gt; node2
    node2 &lt;--&gt; node3
    node3[&#34;node3 (last)&#34;] &lt;==&gt; new_node
    new_node &lt;==&gt; node1
</code></pre><p><code>*start = new_node;</code></p><pre tabindex=0><code class=language-mermaid data-lang=mermaid>flowchart LR
    start --&gt; new_node
    node1 &lt;--&gt; node2
    node2 &lt;--&gt; node3
    node3[&#34;node3 (last)&#34;] &lt;==&gt; new_node
    new_node &lt;==&gt; node1
</code></pre><h3 id=3-funcc-的作用是>3. FuncC 的作用是？</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>FuncC</span>(<span style=color:#66d9ef>struct</span> node <span style=color:#f92672>**</span>start, <span style=color:#66d9ef>int</span> value1, <span style=color:#66d9ef>int</span> value2) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> node <span style=color:#f92672>*</span>new_node <span style=color:#f92672>=</span> <span style=color:#a6e22e>malloc</span>(<span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>struct</span> node));
</span></span><span style=display:flex><span>    new_node<span style=color:#f92672>-&gt;</span>data <span style=color:#f92672>=</span> value1;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> node <span style=color:#f92672>*</span>temp <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>start;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (temp<span style=color:#f92672>-&gt;</span>data <span style=color:#f92672>!=</span> value2)
</span></span><span style=display:flex><span>        temp <span style=color:#f92672>=</span> temp<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> node <span style=color:#f92672>*</span>next <span style=color:#f92672>=</span> temp<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>    temp<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> new_node;
</span></span><span style=display:flex><span>    new_node<span style=color:#f92672>-&gt;</span>prev <span style=color:#f92672>=</span> temp;
</span></span><span style=display:flex><span>    new_node<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> next;
</span></span><span style=display:flex><span>    next<span style=color:#f92672>-&gt;</span>prev <span style=color:#f92672>=</span> new_node;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Find the node with <code>data == value2</code>, if found, insert a node with <code>data == value1</code> after that node.</p><p>Note that <code>*start</code> cannot be <code>NULL</code>.</p><pre tabindex=0><code class=language-mermaid data-lang=mermaid>flowchart LR
    start --&gt; node1
    node1[&#34;node1 [value1]&#34;] &lt;--&gt; node2
    node2[&#34;node2 [value2]&#34;] &lt;--&gt; node3
    node3[&#34;node3 [value3]&#34;] &lt;--&gt; node1
    new_node[&#34;new_node [value1]&#34;]
</code></pre><p><code>struct node *temp = *start;</code></p><pre tabindex=0><code class=language-mermaid data-lang=mermaid>flowchart LR
    start --&gt; node1
    node1[&#34;node1 [value1] (temp)&#34;] &lt;--&gt; node2
    node2[&#34;node2 [value2]&#34;] &lt;--&gt; node3
    node3[&#34;node3 [value3]&#34;] &lt;--&gt; node1
    new_node[&#34;new_node [value1]&#34;]
</code></pre><p><code>while (temp->data != value2) temp = temp->next;</code></p><pre tabindex=0><code class=language-mermaid data-lang=mermaid>flowchart LR
    start --&gt; node1
    node1[&#34;node1 [value1]&#34;] &lt;--&gt; node2
    node2[&#34;node2 [value2] (temp)&#34;] &lt;--&gt; node3
    node3[&#34;node3 [value3]&#34;] &lt;--&gt; node1
    new_node[&#34;new_node [value1]&#34;]
</code></pre><p><code>struct node *next = temp->next;</code></p><pre tabindex=0><code class=language-mermaid data-lang=mermaid>flowchart LR
    start --&gt; node1
    node1[&#34;node1 [value1]&#34;] &lt;--&gt; node2
    node2[&#34;node2 [value2] (temp)&#34;] &lt;--&gt; node3
    node3[&#34;node3 [value3] (next)&#34;] &lt;--&gt; node1
    new_node[&#34;new_node [value1]&#34;]
</code></pre><p><code>temp->next = new_node; new_node->prev = temp;</code></p><pre tabindex=0><code class=language-mermaid data-lang=mermaid>flowchart LR
    start --&gt; node1
    node1[&#34;node1 [value1]&#34;] &lt;--&gt; node2
    node2[&#34;node2 [value2] (temp)&#34;] &lt;==&gt; new_node[&#34;new_node [value1]&#34;]
    node3 --&gt; node2[&#34;node2 [value2] (temp)&#34;]
    node3[&#34;node3 [value3] (next)&#34;] &lt;--&gt; node1
</code></pre><p><code>new_node->next = next; next->prev = new_node;</code></p><pre tabindex=0><code class=language-mermaid data-lang=mermaid>flowchart LR
    start --&gt; node1
    node1[&#34;node1 [value1]&#34;] &lt;--&gt; node2
    node2[&#34;node2 [value2] (temp)&#34;] &lt;==&gt; new_node[&#34;new_node [value1]&#34;]
    node3 &lt;==&gt; new_node
    node3[&#34;node3 [value3] (next)&#34;] &lt;--&gt; node1
</code></pre><h3 id=4-在程式輸出中訊息-traversal-in-forward-direction-後依序印出哪幾個數字呢>4. 在程式輸出中，訊息 Traversal in forward direction 後依序印出哪幾個數字呢？</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// q1.4~10
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> node <span style=color:#f92672>*</span>start <span style=color:#f92672>=</span> NULL; <span style=color:#75715e>// *statr -&gt; NULL
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>FuncA</span>(<span style=color:#f92672>&amp;</span>start, <span style=color:#ae81ff>51</span>); <span style=color:#75715e>// *statr -&gt; 51
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>FuncB</span>(<span style=color:#f92672>&amp;</span>start, <span style=color:#ae81ff>48</span>); <span style=color:#75715e>// *statr -&gt; 48 -&gt; 51
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>FuncA</span>(<span style=color:#f92672>&amp;</span>start, <span style=color:#ae81ff>72</span>); <span style=color:#75715e>// *statr -&gt; 48 -&gt; 51 -&gt; 72
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>FuncA</span>(<span style=color:#f92672>&amp;</span>start, <span style=color:#ae81ff>86</span>); <span style=color:#75715e>// *statr -&gt; 48 -&gt; 51 -&gt; 72 -&gt; 86
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>FuncC</span>(<span style=color:#f92672>&amp;</span>start, <span style=color:#ae81ff>63</span>, <span style=color:#ae81ff>51</span>); <span style=color:#75715e>// *statr -&gt; 48 -&gt; 51 -&gt; 63 -&gt; 72 -&gt; 86
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>display</span>(start);
</span></span></code></pre></div><p>Answer: 48, 51, 63, 72, 86</p><blockquote><p>[!info]
延伸題目：在上述 doubly-linked list 實作氣泡排序和合併排序，並提出需要額外實作哪些函示才足以達成目標</p></blockquote><p>I work out the exercise in <a href=https://github.com/hfyeh/c-review/blob/214a08ee4546c1a560571e734532c16cc80761f4/linked_list_quiz.c#L50-L130>here</a>.</p><h2 id=q2-考慮以下程式碼推敲程式作用並分析輸出>Q2. 考慮以下程式碼，推敲程式作用並分析輸出。</h2><p><img src=https://i.imgur.com/vIk5eO9.png alt></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* Link list node */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> node {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> data;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> node <span style=color:#f92672>*</span>next;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>FuncX</span>(<span style=color:#66d9ef>struct</span> node <span style=color:#f92672>*</span>head, <span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>data) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> node <span style=color:#f92672>*</span>node;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (node <span style=color:#f92672>=</span> head<span style=color:#f92672>-&gt;</span>next; node <span style=color:#f92672>&amp;&amp;</span> node <span style=color:#f92672>!=</span> head; node <span style=color:#f92672>=</span> node<span style=color:#f92672>-&gt;</span>next)
</span></span><span style=display:flex><span>        (<span style=color:#f92672>*</span>data)<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> node <span style=color:#f92672>-</span> head;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> node <span style=color:#f92672>*</span><span style=color:#a6e22e>node_new</span>(<span style=color:#66d9ef>int</span> data) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> node <span style=color:#f92672>*</span>temp <span style=color:#f92672>=</span> <span style=color:#a6e22e>malloc</span>(<span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>struct</span> node));
</span></span><span style=display:flex><span>    temp<span style=color:#f92672>-&gt;</span>data <span style=color:#f92672>=</span> data; temp<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> temp;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> count <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> node <span style=color:#f92672>*</span>head <span style=color:#f92672>=</span> <span style=color:#a6e22e>node_new</span>(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    head<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> <span style=color:#a6e22e>node_new</span>(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    head<span style=color:#f92672>-&gt;</span>next<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> <span style=color:#a6e22e>node_new</span>(<span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>    head<span style=color:#f92672>-&gt;</span>next<span style=color:#f92672>-&gt;</span>next<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> <span style=color:#a6e22e>node_new</span>(<span style=color:#ae81ff>3</span>);
</span></span><span style=display:flex><span>    head<span style=color:#f92672>-&gt;</span>next<span style=color:#f92672>-&gt;</span>next<span style=color:#f92672>-&gt;</span>next<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> <span style=color:#a6e22e>node_new</span>(<span style=color:#ae81ff>4</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;K1 &gt;&gt; %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#a6e22e>FuncX</span>(head, <span style=color:#f92672>&amp;</span>count) <span style=color:#f92672>?</span> <span style=color:#e6db74>&#34;Yes&#34;</span> <span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;No&#34;</span>);
</span></span><span style=display:flex><span>    head<span style=color:#f92672>-&gt;</span>next<span style=color:#f92672>-&gt;</span>next<span style=color:#f92672>-&gt;</span>next<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> head;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;K2 &gt;&gt; %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#a6e22e>FuncX</span>(head, <span style=color:#f92672>&amp;</span>count) <span style=color:#f92672>?</span> <span style=color:#e6db74>&#34;Yes&#34;</span> <span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;No&#34;</span>);
</span></span><span style=display:flex><span>    head<span style=color:#f92672>-&gt;</span>next<span style=color:#f92672>-&gt;</span>next<span style=color:#f92672>-&gt;</span>next<span style=color:#f92672>-&gt;</span>next<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> head<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;K3 &gt;&gt; %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#a6e22e>FuncX</span>(head, <span style=color:#f92672>&amp;</span>count) <span style=color:#f92672>?</span> <span style=color:#e6db74>&#34;Yes&#34;</span> <span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;No&#34;</span>);
</span></span><span style=display:flex><span>    head<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> head<span style=color:#f92672>-&gt;</span>next<span style=color:#f92672>-&gt;</span>next<span style=color:#f92672>-&gt;</span>next<span style=color:#f92672>-&gt;</span>next<span style=color:#f92672>-&gt;</span>next<span style=color:#f92672>-&gt;</span>next<span style=color:#f92672>-&gt;</span>next<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;K4 &gt;&gt; %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#a6e22e>FuncX</span>(head, <span style=color:#f92672>&amp;</span>count) <span style=color:#f92672>?</span> <span style=color:#e6db74>&#34;Yes&#34;</span> <span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;No&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;K5 &gt;&gt; %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, head<span style=color:#f92672>-&gt;</span>next<span style=color:#f92672>-&gt;</span>data);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;count &gt;&gt; %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, count);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=1-funcx-的作用是>1. FuncX 的作用是？</h3><p>The <code>node && node != head</code> indicates the list could be a singlely linked list or a doubly linked list.</p><p>If it&rsquo;s a singlely linked list, the return value is not zero, and vice versa.</p><p>The <code>*data</code> denotes how long the for loop tranversed, for N elements, <code>*data</code> increases N+1.</p><h3 id=2-k1--後面接的輸出為何>2. K1 &#187; 後面接的輸出為何</h3><p>Before K1, the linked list is singly linked.</p><pre tabindex=0><code class=language-mermaid data-lang=mermaid>flowchart LR
    0 --&gt; 1
    1 --&gt; 2
    2 --&gt; 3
    3 --&gt; 4
</code></pre><p><code>FuncX</code> returns non-zero, <code>count == 4</code></p><p>Ans: &ldquo;Yes&rdquo;</p><h3 id=3-k2--後面接的輸出為何>3. K2 &#187; 後面接的輸出為何</h3><p>Before K2, the linked list is doubly linked.</p><pre tabindex=0><code class=language-mermaid data-lang=mermaid>flowchart LR
    0 --&gt; 1
    1 --&gt; 2
    2 --&gt; 3
    3 --&gt; 0
</code></pre><p><code>FuncX</code> returns zero, <code>count == 4+3 == 7</code></p><p>Ans: &ldquo;No&rdquo;</p><h3 id=4-k3--後面接的輸出為何>4. K3 &#187; 後面接的輸出為何</h3><p>Before K3, the linked list is saem as K2. Additional code does not affect anything.</p><p><code>FuncX</code> return zero, <code>count == 7 + 3 == 10</code></p><p>Ans: &ldquo;No&rdquo;</p><h3 id=5-k4--後面接的輸出為何>5. K4 &#187; 後面接的輸出為何</h3><pre tabindex=0><code class=language-mermaid data-lang=mermaid>flowchart LR
    0 &lt;--&gt; 0
</code></pre><p>Ans: &ldquo;No&rdquo;, <code>count == 10 + 0 == 10</code></p><h3 id=6-k5--後面接的輸出為何>6. K5 &#187; 後面接的輸出為何</h3><p>Ans: 0</p><h3 id=7-count--後面接的輸出為何>7. count &#187; 後面接的輸出為何</h3><p>Ans: 10</p></div><div class=article-list-footer><div class=article-list-tags><a href=https://hfyeh.github.io/tags/blog/></a><a href=https://hfyeh.github.io/tags/linked-list/>Linked List</a>
<a href=https://hfyeh.github.io/tags/draft/></a></div></div></article><footer class="footer scrollappear"><p><span>&copy; 2023 <a href=https://hfyeh.github.io>sharefun</a></span>
<span>Powered by <a href=https://gohugo.io/ rel=noopener target=_blank>Hugo</a></span>
<span>Theme is based on <a href=https://github.com/nielsenramon/chalk rel="noreferrer noopener" target=_blank>Chalk</a></span></p></footer><script>var config={startOnLoad:!0,theme:"forest",classDiagram:{useMaxWidth:!1,htmlLabels:!0}};mermaid.initialize(config),window.mermaid.init(void 0,document.querySelectorAll(".language-mermaid"))</script><style>.language-mermaid>svg{background-color:#e8e8e8}</style></div></div></main><script src=https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js></script>
<script src=https://hfyeh.github.io/javascripts/zooming.min.js></script>
<script src=https://hfyeh.github.io/javascripts/retina.min.js></script>
<script src=https://hfyeh.github.io/javascripts/svgxuse.min.js></script>
<script src=https://ajax.googleapis.com/ajax/libs/webfont/1.6.26/webfont.js></script>
<script src=https://hfyeh.github.io/javascripts/vendor.min.js></script>
<script src=https://hfyeh.github.io/javascripts/webfonts.min.js></script>
<script src=https://hfyeh.github.io/javascripts/scrollappear.min.js></script>
<script src=https://hfyeh.github.io/javascripts/application.min.js></script></body></html>