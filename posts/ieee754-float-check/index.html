<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>C 語言中的浮點數與 IEEE 754 - sharefun</title>
<meta name=description content="今天與同事討論 C 語言中，對一個浮點數取 floor 的問題。剛好最近有看到 IEEE 754 標準如何規範浮點數格式1，就趁此機會仔細驗證一下。仍建議看第一手資料，以下純為記錄和分享用途而已。
先從一個問題開始，我用 GCC 編譯以下的程式碼並執行：

floor(f1), 20 digital points: 2.00000000000000000000
floor(f2), 20 digital points: 3.00000000000000000000
為什麼 2.999999 取 floor 得到 2.0，而 2.9999999 取 floor 會得到 3.0 呢？我們的都知道，是因為浮點數有精度問題，單精度浮點數的精準度在絕大多數的機器上有效位數只到小數後第六位。這篇的目標就是從標準的角度去親自確認這件事情。"><meta name=author content><link rel="preload stylesheet" href=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.css><script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script>MathJax={tex:{inlineMath:[["$","$"]],displayMath:[["$$","$$"]]}}</script><script id=MathJax-script defer src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link rel="preload stylesheet" href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.2/styles/gruvbox-dark.min.css><script defer src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.2/highlight.min.js onload=hljs.initHighlightingOnLoad()></script><link rel=icon type=image/x-icon href=https://hfyeh.github.io/images/favicon.ico><link rel=apple-touch-icon href=https://hfyeh.github.io/images/apple-touch-icon-dark.png><link rel=stylesheet href=https://hfyeh.github.io/stylesheets/dark.css><link rel="preload stylesheet" as=style href=https://hfyeh.github.io/custom.min.css><meta name=generator content="Hugo 0.123.1"><meta property="og:title" content="C 語言中的浮點數與 IEEE 754"><meta property="og:description" content="今天與同事討論 C 語言中，對一個浮點數取 floor 的問題。剛好最近有看到 IEEE 754 標準如何規範浮點數格式1，就趁此機會仔細驗證一下。仍建議看第一手資料，以下純為記錄和分享用途而已。
先從一個問題開始，我用 GCC 編譯以下的程式碼並執行：

floor(f1), 20 digital points: 2.00000000000000000000
floor(f2), 20 digital points: 3.00000000000000000000
為什麼 2.999999 取 floor 得到 2.0，而 2.9999999 取 floor 會得到 3.0 呢？我們的都知道，是因為浮點數有精度問題，單精度浮點數的精準度在絕大多數的機器上有效位數只到小數後第六位。這篇的目標就是從標準的角度去親自確認這件事情。"><meta property="og:type" content="article"><meta property="og:url" content="https://hfyeh.github.io/posts/ieee754-float-check/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-07-02T00:00:00+00:00"><meta property="article:modified_time" content="2019-07-02T00:00:00+00:00"><meta itemprop=name content="C 語言中的浮點數與 IEEE 754"><meta itemprop=description content="今天與同事討論 C 語言中，對一個浮點數取 floor 的問題。剛好最近有看到 IEEE 754 標準如何規範浮點數格式1，就趁此機會仔細驗證一下。仍建議看第一手資料，以下純為記錄和分享用途而已。
先從一個問題開始，我用 GCC 編譯以下的程式碼並執行：

floor(f1), 20 digital points: 2.00000000000000000000
floor(f2), 20 digital points: 3.00000000000000000000
為什麼 2.999999 取 floor 得到 2.0，而 2.9999999 取 floor 會得到 3.0 呢？我們的都知道，是因為浮點數有精度問題，單精度浮點數的精準度在絕大多數的機器上有效位數只到小數後第六位。這篇的目標就是從標準的角度去親自確認這件事情。"><meta itemprop=datePublished content="2019-07-02T00:00:00+00:00"><meta itemprop=dateModified content="2019-07-02T00:00:00+00:00"><meta itemprop=wordCount content="196"><meta itemprop=keywords content="c,"><meta name=twitter:card content="summary"><meta name=twitter:title content="C 語言中的浮點數與 IEEE 754"><meta name=twitter:description content="今天與同事討論 C 語言中，對一個浮點數取 floor 的問題。剛好最近有看到 IEEE 754 標準如何規範浮點數格式1，就趁此機會仔細驗證一下。仍建議看第一手資料，以下純為記錄和分享用途而已。
先從一個問題開始，我用 GCC 編譯以下的程式碼並執行：

floor(f1), 20 digital points: 2.00000000000000000000
floor(f2), 20 digital points: 3.00000000000000000000
為什麼 2.999999 取 floor 得到 2.0，而 2.9999999 取 floor 會得到 3.0 呢？我們的都知道，是因為浮點數有精度問題，單精度浮點數的精準度在絕大多數的機器上有效位數只到小數後第六位。這篇的目標就是從標準的角度去親自確認這件事情。"><meta name=twitter:site content="@SharefunYeh"></head><body><div class="grid grid-centered"><div class=grid-cell><nav class="header-nav scrollappear"><a href=/ class=header-logo title=sharefun>sharefun</a><ul class=header-links><li><a href=https://www.facebook.com/sharefun010407 rel="noreferrer noopener" target=_blank title=Facebook><svg xmlns="http://www.w3.org/2000/svg" class="icon-facebook"><use href="https://hfyeh.github.io/icons/facebook.svg#icon-facebook" xlink:href="https://hfyeh.github.io/icons/facebook.svg#icon-facebook"/></svg></a></li><li><a href=https://github.com/hfyeh rel="noreferrer noopener" target=_blank title=GitHub><svg xmlns="http://www.w3.org/2000/svg" class="icon-github"><use href="https://hfyeh.github.io/icons/github.svg#icon-github" xlink:href="https://hfyeh.github.io/icons/github.svg#icon-github"/></svg></a></li><li><a href=https://twitter.com/SharefunYeh rel="noreferrer noopener" target=_blank title=Twitter><svg xmlns="http://www.w3.org/2000/svg" class="icon-twitter"><use href="https://hfyeh.github.io/icons/twitter.svg#icon-twitter" xlink:href="https://hfyeh.github.io/icons/twitter.svg#icon-twitter"/></svg></a></li></ul></nav><article class="article scrollappear"><header class=article-header><h1>C 語言中的浮點數與 IEEE 754</h1></header><div class=article-list-header><span class=article-list-date>July 2, 2019</span></div><div class=article-content><p>今天與同事討論 C 語言中，對一個浮點數取 floor 的問題。剛好最近有看到 IEEE 754 標準如何規範浮點數格式<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>，就趁此機會仔細驗證一下。仍建議看第一手資料，以下純為記錄和分享用途而已。</p><p>先從一個問題開始，我用 GCC 編譯以下的程式碼並執行：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>floor<span style=color:#f92672>(</span>f1<span style=color:#f92672>)</span>, <span style=color:#ae81ff>20</span> digital points: 2.00000000000000000000
</span></span><span style=display:flex><span>floor<span style=color:#f92672>(</span>f2<span style=color:#f92672>)</span>, <span style=color:#ae81ff>20</span> digital points: 3.00000000000000000000
</span></span></code></pre></div><p>為什麼 2.999999 取 floor 得到 2.0，而 2.9999999 取 floor 會得到 3.0 呢？我們的都知道，是因為浮點數有精度問題，單精度浮點數的精準度在絕大多數的機器上有效位數只到小數後第六位。這篇的目標就是從標準的角度去親自確認這件事情。</p><p>首先，單精度浮點數是 32 bits，任何的小數都會轉換成二進制的科學符號後被存在這 32 個位元裡。</p><p>借用 Wikipedia 的圖</p><p>這 32 個 bit，被分成三大部分，Sign、Exponent、Fraction（或稱 Significand/Mantissa）。</p><ul><li>Sign：0 表示為正數，1 表示為負數。</li><li>Exponent：共 8 bits，值為 0~255，代表 2 的指數次方。由於指數也需要有正負號，如採用 Two&rsquo;s Complement 來代表正負，則 0 到 127 代表 0 到 127，128 到 255 代表 -128 到 -1。</li><li>Significand：共 23 bits，但由於規定第一有效位一定要是 1，故有 24 有效位數<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>。</li></ul><p>使用<a href=https://www.h-schmidt.net/FloatConverter/IEEE754.html>這個轉換器</a>可以知道，當想要對 f1 這個長度 8 bits 的記憶體位置存入 2.999999 時，其實際存起來的的值是 2.99999904632568359375。有效位為小數後六位（最低位 2^-23 = 0.000000119209&mldr; 為可存的離散數間的最小間隔）。對這個值取 float，自然就是得到 2.0。而對 f2 這個長度 8 bits 的記憶體位置存入 2.9999999 時，實際存起來的值是 3.0，對 3.0 取 floor 會得到 3.0。</p><p>可以實際執行下列程式確認這點。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>f1, <span style=color:#ae81ff>6</span> digital points: 2.999999
</span></span><span style=display:flex><span>f2, <span style=color:#ae81ff>6</span> digital points: 3.000000
</span></span><span style=display:flex><span>f1, <span style=color:#ae81ff>20</span> digital points: 2.99999904632568359375
</span></span><span style=display:flex><span>f2, <span style=color:#ae81ff>20</span> digital points: 3.00000000000000000000
</span></span><span style=display:flex><span>floor<span style=color:#f92672>(</span>f1<span style=color:#f92672>)</span>, <span style=color:#ae81ff>20</span> digital points: 2.00000000000000000000
</span></span><span style=display:flex><span>floor<span style=color:#f92672>(</span>f2<span style=color:#f92672>)</span>, <span style=color:#ae81ff>20</span> digital points: 3.00000000000000000000
</span></span></code></pre></div><p>同時也可以發現，<code>printf</code> 是會對其參數做過一些處理才顯示出來的（15:16）
，這是為什麼有時候我們不能盡信 <code>printf</code> 給出的資訊的原因。用 GDB 或 Compiler 提供的 Debugger 直接對記憶體求值，才會得到未經處理的真實值。</p><p>參考資料：https://www.bottomupcs.com/types.xhtml</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>舉例來說，可以參考 IEEE 754 對<a href=https://zh.wikipedia.org/wiki/%E5%96%AE%E7%B2%BE%E5%BA%A6%E6%B5%AE%E9%BB%9E%E6%95%B8>單精度浮點數</a>的定義。&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>先假設我們只有 4 bits Significand 可用，Exponent 為 0 的情況下，0.5 會是這樣存 <code>0100</code>，其十進位換算方式是 <code>(0*2^0 + 1*2^-1 + 0*2^-2 + 0*2^-3)*2^0 = 0.5</code>，但這樣存的缺點是能存的離散數的差只有到 2^-3 = 0.125。假如我們規定首位一定要是 1（就像十進位的科學記號，個位數一定會大於零），以此例來說，我們需要向左推兩位，Siginicant bits 就會變成 <code>(1)0000</code>，同時因為對 Significand 左推，Exponent 必須減二變為 -2，計算結果就變成 <code>(1*2^0 + 0*2^-1 + 0*2^-2 + 0*2^-3 + 0*2^-4)*2^-1 = 0.5</code>，會得到一樣的結果，但是能存的離散數的差變小為 2^-4 = 0.0625。&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><div class=article-list-footer><div class=article-list-tags><a href=https://hfyeh.github.io/tags/c/></a></div></div></article><footer class="footer scrollappear"><p><span>&copy; 2024 <a href=https://hfyeh.github.io/>sharefun</a></span>
<span>Powered by <a href=https://gohugo.io/ rel=noopener target=_blank>Hugo</a></span>
<span>Theme is based on <a href=https://github.com/nielsenramon/chalk rel="noreferrer noopener" target=_blank>Chalk</a></span></p></footer><script>var config={startOnLoad:!0,theme:"forest",classDiagram:{useMaxWidth:!1,htmlLabels:!0}};mermaid.initialize(config),window.mermaid.init(void 0,document.querySelectorAll(".language-mermaid"))</script><style>.language-mermaid>svg{background-color:#e8e8e8}</style></div></div></main><script src=https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js></script><script src=https://hfyeh.github.io/javascripts/zooming.min.js></script><script src=https://hfyeh.github.io/javascripts/retina.min.js></script><script src=https://hfyeh.github.io/javascripts/svgxuse.min.js></script><script src=https://ajax.googleapis.com/ajax/libs/webfont/1.6.26/webfont.js></script><script src=https://hfyeh.github.io/javascripts/vendor.min.js></script><script src=https://hfyeh.github.io/javascripts/webfonts.min.js></script><script src=https://hfyeh.github.io/javascripts/scrollappear.min.js></script><script src=https://hfyeh.github.io/javascripts/application.min.js></script></body></html>